name: Build and Deploy Ecommerce Locally

on:
  push:
    branches: ["main"]

jobs:
  build-and-deploy:
    runs-on: [self-hosted, wsl, docker]

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    # Recreate env files (these secrets come from GitHub repo settings)
    - name: ğŸ” Recreate backend.env and frontend.env from secrets
      run: |
        echo "${{ secrets.BACKEND_ENV_FILE }}" > backend.env
        echo "${{ secrets.FRONTEND_ENV_FILE }}" > frontend.env

    # Copy them where the app expects them (this matches your Jenkins logic)
    - name: ğŸ“ Place env files in backend and frontend
      run: |
        # backend expects .env in root (adjust if your backend is in /server or /api)
        cp backend.env .env

        # frontend expects .env inside client/.env (matches your Jenkins script)
        mkdir -p client
        cp frontend.env client/.env

    # Optional: verify nginx config like in Jenkins
    - name: ğŸ” Verify Nginx config exists
      run: |
        if [ ! -f nginx/conf.d/default.conf ]; then
          echo "âŒ Nginx config file missing!"
          exit 1
        else
          echo "âœ… Nginx config found."
        fi

    # Build images using docker compose (must have docker-compose.yml in repo)
    - name: ğŸ”¨ Build Docker images
      run: |
        docker compose build

    # Bring containers up (this *deploys* to your WSL runner machine)
    - name: ğŸš€ Deploy with docker compose
      run: |
        docker compose up -d

    # Show running containers, like Jenkins did
    - name: ğŸ“¦ Check running containers
      run: |
        docker ps

    # Cleanup the sensitive .env files from disk
    - name: ğŸ§¹ Cleanup env files
      if: always()
      run: |
        rm -f .env client/.env backend.env frontend.env
